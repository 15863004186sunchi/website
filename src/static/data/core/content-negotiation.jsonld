{"@id":"core/content-negotiation.jsonld","@context":"http://schema.org","@type":"CreativeWork","name":"Content Negotiation","text":"\u003ch1\u003eContent Negotiation\u003c/h1\u003e\n\n\u003cp\u003eThe API system has builtin \u003ca href=\"https://en.wikipedia.org/wiki/Content_negotiation\"\u003econtent negotiation\u003c/a\u003e capabilities.\nIt leverages the \u003ca href=\"https://github.com/willdurand/Negotiation\"\u003e\u003ccode\u003ewilldurand/negotiation\u003c/code\u003e\u003c/a\u003e library.\u003c/p\u003e\n\n\u003cp\u003eBy default, only the \u003ca href=\"https://json-ld.org\"\u003eJSON-LD\u003c/a\u003e format is enabled. However API Platform Core supports many more formats and can be extended.\u003c/p\u003e\n\n\u003cp\u003eThe framework natively supports JSON-LD, HAL, raw JSON, XML, YAML and CSV (YAML and CSV support is only available if you use Symfony 3.2+).\u003c/p\u003e\n\n\u003cp\u003eBoth XML and JSON formats are experimental and there are no assurance that we will not break them.\u003c/p\u003e\n\n\u003cp\u003eAPI Platform Core will automatically detect the best resolving format depending on:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eenabled formats (link to docs for this / see below)\u003c/li\u003e\n\u003cli\u003ethe \u003ccode\u003eAccept\u003c/code\u003e HTTP header\u003c/li\u003e\n\u003cli\u003eAlternatively to send the proper \u003ccode\u003eAccept\u003c/code\u003e HTTP header, you can also request a specific format by adding its name as the extension of the URL.\u003c/li\u003e\n\u003cli\u003eAvailable formats are :\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eFormat\u003c/th\u003e\n\u003cth\u003eFormat name\u003c/th\u003e\n\u003cth\u003eMIME types\u003c/th\u003e\n\u003cth\u003eBackward Compatibility guaranteed\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://json-ld.org\"\u003eJSON-LD\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ejsonld\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eapplication/ld+json\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eyes\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"http://stateless.co/hal_specification.html\"\u003eHAL\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ejsonhal\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eapplication/hal+json\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eyes\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003eJSON\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ejson\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eapplication/json\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eno\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003eXML\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003exml\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eapplication/xml\u003c/code\u003e, \u003ccode\u003etext/xml\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eno\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003eHTML (API docs)\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ehtml\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003etext/html\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eno\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003eIf the client requested format is not specified (if it’s not supported, it will throw an HTTP bad format error), the response format will be the first format defined in the \u003ccode\u003eformats\u003c/code\u003e configuration key (see below).\nAn example using the builtin XML support is available in \u003ca href=\"https://github.com/api-platform/core/blob/master/features/main/content_negotiation.feature\"\u003eBehat specs\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe API Platform content negotiation system is extensible. Support for other formats (such as \u003ca href=\"http://jsonapi.org/\"\u003eJSONAPI\u003c/a\u003e)\ncan be added by \u003ca href=\"https://symfony.com/doc/current/serializer.html#adding-normalizers-and-encoders\"\u003ecreating and registering appropriate encoders and, sometimes, normalizers\u003c/a\u003e. Adding support for other\nstandard hypermedia formats upstream is very welcome. Don’t hesitate to contribute by adding your encoders and normalizers\nto API Platform Core.\u003c/p\u003e\n\n\u003ch2\u003eEnabling Several Formats\u003c/h2\u003e\n\n\u003cp\u003eThe first required step is to configure allowed formats. The following configuration will enable the support of XML (built-in)\nand of a custom format called \u003ccode\u003emyformat\u003c/code\u003e and having \u003ccode\u003eapplication/vnd.myformat\u003c/code\u003e as \u003ca href=\"https://en.wikipedia.org/wiki/Media_type\"\u003eMIME type\u003c/a\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# app/config/config.yml\n\napi_platform:\n\n    # ...\n\n    formats:\n        jsonld:   [\u0026#39;application/ld+json\u0026#39;]\n        jsonhal:  [\u0026#39;application/hal+json\u0026#39;]\n        json:     [\u0026#39;application/json\u0026#39;]\n        xml:      [\u0026#39;application/xml\u0026#39;, \u0026#39;text/xml\u0026#39;]\n        html:     [\u0026#39;text/html\u0026#39;]\n        myformat: [\u0026#39;application/vnd.myformat\u0026#39;]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eBecause the Symfony Serializer component is able to serialize objects in XML, sending an \u003ccode\u003eAccept\u003c/code\u003e HTTP header with the\n\u003ccode\u003etext/xml\u003c/code\u003e string as value is enough to retrieve XML documents from our API. However API Platform knows nothing about the\n\u003ccode\u003emyformat\u003c/code\u003e format. We need to register an encoder and optionally a normalizer for this format.\u003c/p\u003e\n\n\u003ch2\u003eRegistering a Custom Serializer\u003c/h2\u003e\n\n\u003cp\u003eIf you are adding support for a format not supported by default by API Platform nor by the Symfony Serializer Component,\nyou need to create custom encoder, decoder and eventually a normalizer and a denormalizer. Refer to the\nSymfony documentation to learn \u003ca href=\"https://symfony.com/doc/current/cookbook/serializer.html#adding-normalizers-and-encoders\"\u003ehow to create and register such classes\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eAPI Platform Core will automatically call the serializer with your defined format name (\u003ccode\u003emyformat\u003c/code\u003e in previous examples)\nas \u003ccode\u003eformat\u003c/code\u003e parameter during the deserialization process. Then it will return the result to the client with the asked MIME\ntype using its built-in responder.\u003c/p\u003e\n\n\u003ch2\u003eWriting a Custom Normalizer\u003c/h2\u003e\n\n\u003cp\u003eUsing composition is the recommended way to implement a custom normalizer. You can use the following template to start with your\nown implementation of \u003ccode\u003eCustomItemNormalizer\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# app/config/services.yml\n\nservices:\n\n# ...\n\n    \u0026#39;AppBundle\\Serializer\\CustomItemNormalizer\u0026#39;:\n        arguments: [ \u0026#39;@api_platform.serializer.normalizer.item\u0026#39; ]\n        tags: [ \u0026#39;serializer.normalizer\u0026#39; ]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-php\"\u003e\u0026lt;?php\n\n// src/AppBundle/Serializer/CustomItemNormalizer.php\n\nnamespace AppBundle\\Serializer;\n\nuse Symfony\\Component\\Serializer\\Normalizer\\DenormalizerInterface;\nuse Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface;\n\nfinal class CustomItemNormalizer implements NormalizerInterface, DenormalizerInterface\n{\n    private $normalizer;\n\n    public function __construct(NormalizerInterface $normalizer)\n    {\n        if (!$normalizer instanceof DenormalizerInterface) {\n            throw new \\InvalidArgumentException(\u0026#39;The normalizer must implement the DenormalizerInterface\u0026#39;);\n        }\n\n        $this-\u0026gt;normalizer = $normalizer;\n    }\n\n    public function denormalize($data, $class, $format = null, array $context = [])\n    {\n        return $this-\u0026gt;normalizer-\u0026gt;denormalize($data, $class, $format, $context);\n    }\n\n    public function supportsDenormalization($data, $type, $format = null)\n    {\n        return $this-\u0026gt;normalizer-\u0026gt;supportsDenormalization($data, $type, $format);\n    }\n\n    public function normalize($object, $format = null, array $context = [])\n    {\n        return $this-\u0026gt;normalizer-\u0026gt;normalize($object, $format, $context);\n    }\n\n    public function supportsNormalization($data, $format = null)\n    {\n        return $this-\u0026gt;normalizer-\u0026gt;supportsNormalization($data, $format);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFor example if you want to make the \u003ccode\u003ecsv\u003c/code\u003e format to work for even complex entities with a lot of hierarchy, you have\nto flatten or remove too complex relations:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-php\"\u003e\u0026lt;?php\n\n// src/AppBundle/Serializer/CustomItemNormalizer.php\n\nnamespace AppBundle\\Serializer;\n\nuse Symfony\\Component\\Serializer\\Normalizer\\DenormalizerInterface;\nuse Symfony\\Component\\Serializer\\Normalizer\\NormalizerInterface;\n\nclass CustomItemNormalizer implements NormalizerInterface, DenormalizerInterface\n{\n    // ...\n\n    public function normalize($object, $format = null, array $context = [])\n    {\n        $result = $this-\u0026gt;normalizer-\u0026gt;normalize($object, $format, $context);\n\n        if (\u0026#39;csv\u0026#39; !== $format || !is_array($result)) {\n            return $result;\n        }\n\n        foreach ($result as $key =\u0026gt; $value) {\n            if (is_array($value) \u0026amp;\u0026amp; array_keys(array_keys($value)) === array_keys($value)) {\n                unset($result[$key]);\n            }\n        }\n\n        return $result;\n    }\n    \n    // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ePrevious chapter: \u003ca href=\"events.jsonld\"\u003eThe Event System\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eNext chapter: \u003ca href=\"external-vocabularies.jsonld\"\u003eUsing External JSON-LD Vocabularies\u003c/a\u003e\u003c/p\u003e\n","author":[{"@type":"Person","name":"Jonathan Goncalves","email":"jgoncalves@a5sys.com"},{"@type":"Person","name":"Thomas Kekeisen","email":"github@tk.ca.kekeisen.it"},{"@type":"Person","name":"Prou Yann","email":"yann@les-tilleuls.coop"},{"@type":"Person","name":"meyerbaptiste","email":"baptiste@les-tilleuls.coop"},{"@type":"Person","name":"Kevin Saliou","email":"kevin@saliou.name"},{"@type":"Person","name":"Amrouche Hamza","email":"laharl.moon@gmail.com"},{"@type":"Person","name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","name":"hamza","email":"hamza@oblady.fr"}],"dateCreated":"2016-03-30T22:29:36+02:00","dateModified":"2017-09-26T14:06:51+02:00"}